# 说明


## Two sum
- 排序后遍历：左右两端往中间靠拢
- 用Map先存下所有arr的位置，重复的元素用另一个map存下。遍历map，看target-k是否在map里
- 在上面一种方案上简化，一边遍历数组，一边将元素放入map中。

## AddTwoNumbers
没什么别的，注意是所有的条件都判断到了就行。
改进点：可以对两颗树分别判断来简化代码，可以写成两个if里

## LengthOfLongestSubstring
用一个map记录最长字串每个字符的位置，同时有两个指针指向这个最长字串的首尾，遍历时移动这两个指针，找到最长的串

## LongestPalindrome
最长回文子串，这题想了很久，其实早就有思路了，只是一直在想比o(n)还快的思路，以后写题目，每种思路先把时间复杂度和空间复杂度，写出来后，再考虑更好的方法。
遍历字符串，每个位置，有两种可能(a和aa)，然后在此基础上向外扩展，时间复杂度为o(n2)

## ZigZagConversion
将一个字符串排成锯齿形的再重新打印。我用的方法是找规律，然后直接访问找到这个字母，然后拼进去。
在网上有另一种思路就是，记录n个字符串，然后顺序访问原字符串，将字符填充进去最后再拼在一起形成新的字符串。

## ReverseInteger
反转数字。两个点：第一，对于负数/10或者%10，结果都是负数，所以不需要负数单独来出来判断
第二，边界判定问题，每次加和之前都需要判断当前这个数加之后是否超过边界

##StringToInteger
字符串转数字，主要还是条件判断，这里我的代码显得有些臃肿，其实可以精简。
这题和上一题不一样的地方是，如果越界就返回相应的int的最大值和最小值。所以在做边界判断的时候可以简化，可以只按正数的最大值判断，最后再加上正负号就可以了。

##PalindromeNumber
是否是回文数字，这道题刚开始写的时候先求的回文数字再做比较。后来看了其他思路，想到了回文数字，其实只要求一半就可以了，这样速度会快很多。
然后需要判断些极端情况，小于0，等于0，负数，尾数是0等等

##RegularExpressionMatching
正则表达式，采用递归或者动规划的方法解决。主要是需要解决*的问题。这里采用了递归的方法，对于第二位是*的模式，循环里套递归，主要有一个匹配上就ok了。
动态规划的方法暂时没想出来

##ContainerWithMostWater
没什么好说的，感觉得头脑清醒的时候再想问题

##IntegerToRoman
数字转成罗马数字，这道题没什么难度。主要是如何把时间降低。代码里有可以优化的地方，我的思路可以进一步优化，将固定的字符串完全提出来在一开始初始化好，提升速度。

##RomanToInteger
罗马数字转阿拉伯数字，没什么难度，和上一题反过来。代码有可以优化的地方。比如说发现，在遍历string的时候，是单个遍历的，可以先转成char数字在遍历，速度会快很多。

##LongestCommonPrefix
最长公共前缀。这道题的问题在于有一些算法，可能存在更快的算法

##ThreeSum
三个数求和，这道题我的解法虽然没有问题，但是臃肿了。结合了两种方法，但是效率变低了。
应该是遍历的方法3sum就变成2sum，在知道targer的情况下，
第一种用map结合找到另外两个值，如果不考虑重复的问题，可以用这种方法
第二种是先排序后，然后两头向中间搜索，考虑重复的问题，所以用这种方法更好

##threeSumClosest
三个数求和，给定一个值，找到三个数使他们的和最接近给定值。
这道题接上道题而来，思路是有，但是因为边界原因，导致提交了多次才通过。看了这道题的解法，
总结的我老是走歪路。虽然不影响结果，但是一定程度影响了速度

#Letter Combinations of a Phone Number
这道题花了很久，问题在于，总想找到个好方法。把简单和直接的方法遗漏了。
这道题，关键是要产生一定数量的String，可以先把已知的str去掉，生成新的str再加入

##FourSum
四个数求和。这道题解法和三个数求和类似。注意点，一个是去重和边界的问题，四个位置每次的前进后退都要考虑重复问题。
第二个是，在开始的时候做一些最小最大的判断，可以过滤掉很多case，节省时间

##RemoveNthNodeFromEndofList
将一个链表的倒数第n个数字删掉。这道题我的思路是对的。有一个优化点是可以在做边界处理的时候，其实可以加一个节点放在表头。

##MergeTwoSortedLists
两个有序列表合并。问题不难。看到一个很好的解法，就是用递归的方法，代码更简洁

##GenerateParentheses
生成所有的括号序列对。自己想到的方法和网上的方法对比，都是递归，网上的方法比我多了一个变量，可能更好理解。
我控制了一个左括号生成个数这个变量，网上的方法没有控制这个变量。都差不多。

##MergeKSortedLists
合并k个有序列表。这道题收获挺大的。我的做法是compareonebyone，用递归的方法，空间复杂度o(1),时间复杂度o(kN).
优先队列（最小堆）的方法优化了我的方法，大幅度减少了时间复杂度，变为O(Nlogk)。
还有一种方法，类似归并排序，还没试过。

##SwapNodesInPairs
迭代和递归两种方法

##ReverseNodesInKGroup
递归的方法，一道hard题目。空间复杂度为o(1)，用递归的方法

##RemoveDuplicatesFromSortedArray
两个点，一个指项去除重复元素后数组的，另一个指向原数组

##RemoveElement
和上一题差不多，可以用一样的方法。如果可以改变数组元素的位置，可以每次把最后一个元素往前交换，提升速度

##ImplementStrStr
实现java的indexof，很简单。如果用kmp速度应该会快很多

##DivideTwoIntegers *
这道题很有意思，一开始没有思路。两个点：
（1）思考这道题，把最后的结果拆成二进制的形式，倒推实现。
（2）第二点是越界问题。这个真巧妙，因为用负数不会越界，所以把所有的数换成负数来操作

##SubstringwithConcatenationofAllWords
这道题花了我太多的时间，归结原因还是想复杂了，总觉得有一种特别简单的方法解决，其实真的不一定有这种方法。
还是老老实实按照常规方法来解决就行

##NextPermutation
这道题，花了点时间，但总算找到了规律。分析题目的本质（全排列，找到规律）。从右向左扫描，找到第一个不是降序排列的数字，将这个数字与降序数组中比
他的数字交换。然后将降序数组升序排列即可